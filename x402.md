# Setting Up x402 Payment Routes with bhvr.dev

This guide explains how to implement x402 payment-protected API routes using the [bhvr.dev](https://bhvr.dev) stack (Bun + Hono + Vite + React). x402 is a protocol for enabling micropayments on HTTP APIs, allowing you to monetize API endpoints with minimal friction.

## Table of Contents

- [Overview](#overview)
- [Architecture](#architecture)
- [Server Setup](#server-setup)
- [Client Setup](#client-setup)
- [Payment Flow](#payment-flow)
- [Configuration](#configuration)
- [Best Practices](#best-practices)

## Overview

x402 enables HTTP APIs to request payments before serving content. When a client makes a request to a protected endpoint:

1. The server responds with a `402 Payment Required` status
2. The response includes payment details (amount, network, recipient)
3. The client signs a payment message and includes it in subsequent requests
4. The server verifies the payment and serves the content

This guide assumes you've scaffolded a project using `bun create bhvr@latest` and have a monorepo structure with:

- `server/` - Cloudflare Workers with Hono
- `clients/` - React/Vite frontend applications
- `sdk/` - Shared SDK for client-server communication
- `shared/` - Shared TypeScript types

## Architecture

```
┌─────────────┐         ┌──────────────┐         ┌─────────────┐
│   Client    │────────▶│    Server    │────────▶│ Facilitator │
│  (Browser)  │  HTTP   │  (Workers)   │  HTTP   │  (x402.org)  │
└─────────────┘         └──────────────┘         └─────────────┘
     │                          │
     │ 1. Request               │
     ├─────────────────────────▶│
     │                          │
     │ 2. 402 + Payment Info    │
     │◀─────────────────────────┤
     │                          │
     │ 3. Sign Payment          │
     │                          │
     │ 4. Request + Signature   │
     ├─────────────────────────▶│
     │                          │ 5. Verify
     │                          ├───────────────▶│
     │                          │◀───────────────┤
     │                          │
     │ 6. 200 + Content          │
     │◀─────────────────────────┤
```

## Server Setup

### 1. Install Dependencies

In your `server/` directory:

```bash
bun add @x402/core @x402/evm @x402/hono
```

### 2. Configure Environment Variables

Add to your `wrangler.json` or `.dev.vars`:

```json
{
  "vars": {
    "X402_PAY_TO": "0x...", // Your wallet address
    "X402_BASE_PRICE": "$0.001", // Minimum price per request
    "X402_NETWORK": "eip155:84532", // Network (e.g., Base Sepolia)
    "X402_FACILITATOR_URL": "https://x402.org/facilitator"
  }
}
```

### 3. Initialize x402 Server

In your `server/src/index.ts`:

```typescript
import { Hono } from "hono";
import { paymentMiddleware } from "@x402/hono";
import { x402ResourceServer, HTTPFacilitatorClient } from "@x402/core/server";
import { registerExactEvmScheme } from "@x402/evm/exact/server";
import type { Network } from "@x402/core/types";

type Bindings = {
  X402_PAY_TO: string;
  X402_BASE_PRICE: string;
  X402_NETWORK: string;
  X402_FACILITATOR_URL: string;
};

const app = new Hono<{ Bindings: Bindings }>();

// Lazy-initialized x402 server (avoids global scope async in Workers)
let x402ServerInstance: x402ResourceServer | null = null;

function getX402Server(facilitatorUrl: string): x402ResourceServer {
  if (!x402ServerInstance) {
    const facilitatorClient = new HTTPFacilitatorClient({ url: facilitatorUrl });
    x402ServerInstance = new x402ResourceServer(facilitatorClient);
    registerExactEvmScheme(x402ServerInstance);
  }
  return x402ServerInstance;
}
```

### 4. Add Payment Middleware

Apply payment middleware to routes that require payment:

```typescript
app.use("/api", async (c, next) => {
  const query = c.req.query();

  // Skip payment if no query params (e.g., redirect to frontend)
  if (!Object.keys(query).length) {
    return next();
  }

  const payTo = c.env.X402_PAY_TO;
  const network = (c.env.X402_NETWORK || "eip155:84532") as Network;
  const facilitatorUrl = c.env.X402_FACILITATOR_URL || "https://x402.org/facilitator";
  const basePrice = c.env.X402_BASE_PRICE || "$0.001";

  if (!payTo) return next();

  // Calculate dynamic price based on query params
  const price = calculatePrice(query, basePrice);
  const server = getX402Server(facilitatorUrl);

  // Apply payment middleware
  const middleware = paymentMiddleware(
    {
      "GET /api": {
        accepts: [
          {
            scheme: "exact",
            price: price,
            network,
            payTo,
          },
        ],
        description: `API request - ${price}`,
        mimeType: "text/plain",
      },
    },
    server
  );

  return middleware(c, next);
});
```

### 5. Implement Free Tier (Optional)

You can implement a free tier that bypasses payment:

```typescript
function isFreeTier(params: QueryParams): boolean {
  // Example: free for up to 10 items
  const limit = params.limit || 50;
  if (limit > 10) return false;
  if (params.includeExtra) return false;
  return true;
}

app.use("/api", async (c, next) => {
  const query = c.req.query();
  if (!Object.keys(query).length) return next();

  // Skip payment for free tier
  if (isFreeTier(query)) {
    return next();
  }

  // ... rest of payment middleware
});
```

### 6. Create Protected Endpoint

```typescript
app.get("/api", async (c) => {
  try {
    const query = c.req.query();

    // Your business logic here
    const data = await fetchData(query);

    c.header("Content-Type", "text/plain");
    return c.text(formatOutput(data));
  } catch (err) {
    return c.text(`Error: ${err instanceof Error ? err.message : "Unknown"}`, 500);
  }
});
```

### 7. Add Price Estimate Endpoint

Provide a free endpoint for clients to check prices:

```typescript
app.get("/api/estimate", async (c) => {
  try {
    const query = c.req.query();

    // Check free tier
    if (isFreeTier(query)) {
      return c.json({ price: "$0", isFree: true });
    }

    // Calculate price
    const price = calculatePrice(query, c.env.X402_BASE_PRICE || "$0.001");

    return c.json({ price, isFree: false });
  } catch (error) {
    return c.json({ error: "Failed to calculate estimate" }, 500);
  }
});
```

## Client Setup

### 1. Install SDK Dependencies

In your `sdk/` directory:

```bash
bun add @x402/core @x402/evm @x402/fetch
```

### 2. Create SDK Client

In `sdk/src/client.ts`:

```typescript
import { wrapFetchWithPayment } from "@x402/fetch";
import { x402Client } from "@x402/core/client";
import { registerExactEvmScheme } from "@x402/evm/exact/client";

export interface EvmSigner {
  address: string;
  signTypedData: (args: any) => Promise<string>;
}

export interface ClientConfig {
  baseUrl?: string;
  signer?: EvmSigner;
  fetch?: typeof globalThis.fetch;
}

export class ApiClient {
  private readonly baseUrl: string;
  private readonly fetchFn: typeof fetch;

  constructor(config: ClientConfig = {}) {
    this.baseUrl = config.baseUrl || "https://api.example.com";

    const baseFetch = config.fetch || globalThis.fetch;

    // Wrap with x402 payment handling if signer is provided
    if (config.signer) {
      const client = new x402Client();
      registerExactEvmScheme(client, { signer: config.signer });
      this.fetchFn = wrapFetchWithPayment(baseFetch, client);
    } else {
      this.fetchFn = baseFetch;
    }
  }

  async fetch(options: QueryOptions): Promise<{ text: string; status: number }> {
    const queryString = new URLSearchParams(options as any).toString();
    const url = `${this.baseUrl}?${queryString}`;

    const response = await this.fetchFn(url, {
      headers: { Accept: "text/plain" },
    });

    const text = await response.text();
    return { text, status: response.status };
  }

  async getEstimate(options: QueryOptions): Promise<{ price: string; isFree: boolean } | null> {
    const queryString = new URLSearchParams(options as any).toString();
    const response = await fetch(`${this.baseUrl}/estimate?${queryString}`);

    if (!response.ok) return null;
    return await response.json();
  }
}
```

### 3. Integrate with React Client

In your React app (e.g., `clients/your-app/src/App.tsx`):

```typescript
import { useState, useMemo } from "react";
import { useWalletClient } from "wagmi";
import { ApiClient, type EvmSigner } from "@your-org/sdk";

function App() {
  const { data: walletClient } = useWalletClient();
  const [data, setData] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  // Create SDK client with wallet signer
  const apiClient = useMemo(() => {
    const signer: EvmSigner | undefined = walletClient?.account
      ? {
          address: walletClient.account.address,
          signTypedData: (args) => walletClient.signTypedData(args as Parameters<typeof walletClient.signTypedData>[0]),
        }
      : undefined;

    return new ApiClient({
      baseUrl: import.meta.env.PROD ? "https://api.example.com" : "/api",
      signer,
    });
  }, [walletClient]);

  const handleFetch = async () => {
    setLoading(true);
    try {
      const result = await apiClient.fetch({ limit: 10 });

      if (result.status === 402) {
        alert("Payment required. Connect wallet to proceed.");
        return;
      }

      setData(result.text);
    } catch (err) {
      console.error(err);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <button onClick={handleFetch} disabled={loading}>
        {loading ? "Loading..." : "Fetch Data"}
      </button>
      {data && <pre>{data}</pre>}
    </div>
  );
}
```

### 4. Set Up Wallet Connection

Install wagmi for wallet connectivity:

```bash
bun add wagmi viem @tanstack/react-query
```

Configure wagmi in your app:

```typescript
import { WagmiProvider, createConfig, http } from "wagmi";
import { baseSepolia } from "wagmi/chains";
import { injected } from "wagmi/connectors";

const config = createConfig({
  chains: [baseSepolia],
  connectors: [injected()],
  transports: {
    [baseSepolia.id]: http(),
  },
});

// Wrap your app
<WagmiProvider config={config}>
  <App />
</WagmiProvider>;
```

## Payment Flow

### 1. Client Makes Request

```typescript
const response = await apiClient.fetch({ limit: 100 });
```

### 2. Server Responds with 402

If payment is required, the server responds:

```
HTTP/1.1 402 Payment Required
X-Payment-Response: {
  "price": "$0.005",
  "network": "eip155:84532",
  "payTo": "0x...",
  "scheme": "exact"
}
```

### 3. Client Signs Payment

The SDK automatically:

- Detects the 402 response
- Extracts payment details
- Prompts the user's wallet to sign
- Includes the signature in a retry request

### 4. Server Verifies and Serves

The server:

- Verifies the payment signature via the facilitator
- Serves the requested content
- Returns 200 OK

## Configuration

### Network IDs

Common network IDs for x402:

- `eip155:84532` - Base Sepolia (testnet)
- `eip155:8453` - Base Mainnet
- `eip155:1` - Ethereum Mainnet
- `eip155:11155111` - Sepolia (testnet)

### Price Format

Prices are specified as dollar amounts:

- `"$0.001"` - One millidollar
- `"$0.01"` - One cent
- `"$1.00"` - One dollar

### Dynamic Pricing

You can calculate prices based on request parameters:

```typescript
function calculatePrice(params: QueryParams, basePrice: string): string {
  const base = parseFloat(basePrice.replace("$", ""));
  let cost = base;

  // Add cost per item
  if (params.limit) {
    cost += params.limit * 0.0001;
  }

  // Multiplier for extra features
  if (params.includeExtra) {
    cost *= 1.5;
  }

  // Round to 6 decimal places
  const rounded = Math.round(cost * 1000000) / 1000000;
  return `$${rounded}`;
}
```

## Best Practices

### 1. Free Tier Strategy

- Offer a generous free tier to reduce friction
- Use free tier for basic use cases
- Require payment for advanced features or large requests

### 2. Price Transparency

- Always provide an `/estimate` endpoint
- Show prices in the UI before making requests
- Cache estimates to reduce server load

### 3. Error Handling

```typescript
try {
  const result = await apiClient.fetch(options);

  if (result.status === 402) {
    // Payment required - guide user to connect wallet
  } else if (result.status === 400) {
    // Invalid request
  } else if (result.status === 500) {
    // Server error
  }
} catch (err) {
  // Network or other errors
}
```

### 4. Caching

- Cache price estimates on the client
- Use fingerprinting to invalidate cache when params change
- Set appropriate TTLs (e.g., 1 minute for estimates)

### 5. Rate Limiting

Implement rate limiting on your server to prevent abuse:

```typescript
class RateLimiter {
  private requests = new Map<string, number[]>();
  private readonly LIMIT = 100;
  private readonly WINDOW_MS = 60000;

  async waitForSlot(identifier: string): Promise<void> {
    const now = Date.now();
    const recent = (this.requests.get(identifier) || []).filter((t) => now - t < this.WINDOW_MS);

    if (recent.length >= this.LIMIT) {
      const waitTime = this.WINDOW_MS - (now - recent[0]);
      await new Promise((resolve) => setTimeout(resolve, waitTime));
      return this.waitForSlot(identifier);
    }

    recent.push(now);
    this.requests.set(identifier, recent);
  }
}
```

### 6. Testing

Test your payment flow:

1. **Free tier requests** - Should work without wallet
2. **Paid requests without wallet** - Should return 402
3. **Paid requests with wallet** - Should complete successfully
4. **Price estimates** - Should return accurate prices

### 7. Monitoring

Monitor key metrics:

- 402 response rate (payment required)
- Payment success rate
- Average payment amount
- Free tier usage vs paid usage

## Troubleshooting

### Payment Not Working

- Verify wallet is connected and on the correct network
- Check that `X402_NETWORK` matches the wallet's network
- Ensure facilitator URL is correct
- Check browser console for signing errors

### 402 Not Triggering

- Verify payment middleware is applied to the route
- Check that query params are present (middleware may skip empty queries)
- Ensure `X402_PAY_TO` is set in environment variables
- Verify free tier logic isn't bypassing payment

### Price Calculation Issues

- Use the `/estimate` endpoint to verify server-side pricing
- Ensure price format is correct (`"$0.001"` not `0.001`)
- Check that dynamic pricing logic matches between estimate and actual request

## Resources

- [x402 Protocol](https://x402.org)
- [bhvr.dev Documentation](https://bhvr.dev)
- [Hono Documentation](https://hono.dev)
- [Wagmi Documentation](https://wagmi.sh)

## Example Project Structure

```
your-project/
├── server/
│   ├── src/
│   │   └── index.ts          # Hono app with x402 middleware
│   ├── wrangler.json          # Cloudflare Workers config
│   └── package.json
├── sdk/
│   ├── src/
│   │   └── client.ts          # x402-enabled client SDK
│   └── package.json
├── clients/
│   └── your-app/
│       ├── src/
│       │   └── App.tsx        # React app using SDK
│       └── package.json
└── shared/
    └── src/
        └── types.ts           # Shared TypeScript types
```

This structure allows you to:

- Share types between server and client
- Reuse the SDK across multiple client apps
- Deploy server and clients independently
- Maintain type safety across the stack
