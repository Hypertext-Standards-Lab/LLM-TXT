- **Monorepo Structure:** Follow the BHVR templateâ€™s organization â€“ a workspaces-based monorepo with three main packages: `server/` for the Hono backend, `client/` for the React frontend, and `shared/` for common TypeScript types. Use `shared/src/types/index.ts` to export any shared types. Each directory is self-contained: Hono handlers (e.g. `mcp.ts`) live under `server/src/`, React components and assets under `client/`, and common interfaces under `shared/`. This clear separation keeps modular logic coherent and matches the BHVR conventions.
- **Naming Conventions:** Use consistent file and symbol naming. File names should be lowercase kebab-case for routes and modules (e.g. `mcp.ts`, `llm-generator.ts`); React components and exported types should use PascalCase. Adopt standard extensions: `.ts` for backend and shared files, `.tsx` for React components. Expose shared types via `export * from "./types"` in `shared/src/index.ts`. This mirrors BHVR patterns of shared modules.
- **Tech Stack Guidelines:** The backend is built with **Hono** (TypeScript) on Cloudflare Workers (via Bun or Node). Hono routes should be defined in `server/src/index.ts` or separated routers, e.g. `app.get('/mcp', ...)`. The frontend is a minimal React/Vite app deployed on **Orbiter** (a simple static host) or similar. The `.cursorrules` context reminds the AI that â€œHono is the chosen backend frameworkâ€ and that Orbiter will host static files. Database and persistence are _not_ required â€“ everything is in-memory/ephemeral.
- **Style & Tone (Vibe):** Maintain a precise, technical style with a slight developer-friendly flair. Instructions should be concise and factual, but express enthusiasm for correctness. For example, log or comment messages might use clear, constructive language (e.g. â€œFetching user dataâ€¦â€ or â€œğŸ“‚ Writing context file llm-123.txtâ€). Keep the UX developer-oriented: the output is a raw text file, so the â€œvibeâ€ is efficient and no-nonsense, yet helpful. Cursorâ€™s rules emphasize consistency and clarity, so do not deviate into overly casual language or ambiguous terms.
- **UX Alignment:** The endpoint serves LLM clients directly, so there is no rich UI beyond perhaps a simple status page. Ensure any text output is LLM-friendly: use natural language with explicit labels (e.g. â€œDisplay Name: FooBarâ€), separate sections with headers or blank lines, and avoid formatting that could confuse parsing. File naming and MIME types must be correct: e.g. response header `Content-Disposition: attachment; filename=llm-<fid>.txt` so that the file is downloaded with the intended name. The â€œvibeâ€ here is transparent â€“ the user (or LLM) gets exactly what it needs without extra markup.
- **Agility & Statelessness:** Since the service is ephemeral, do not implement caching or data storage. Every request to `/mcp` should fetch fresh data from Snapchain (as suggested by the Farcaster docs). This rule ensures data is up-to-date and respects privacy. In code, avoid any global caches; treat each invocation as independent.
- **Cursor Rule Context:** Remember that this `.cursorrules` file itself provides system-level guidance for Cursorâ€™s AI (legacy project rule format). These guidelines should be automatically prepended to the modelâ€™s context when editing or generating code, so format them clearly. For example, begin with a brief bullet summary of project scope (â€œFullstack TS monorepo with Hono backend and Vite/React frontendâ€), then detail the above points in separate bullets. The agent should see these rules and then apply them consistently when writing code.
